#!/mnt/lustre_fs/users/mjmcc/apps/python2.7/bin/python
# ----------------------------------------
# USAGE:

# ----------------------------------------
# PREAMBLE:

import numpy as np
from numpy.linalg import *
import MDAnalysis
#from MDAnalysis.analysis.align import *
from MDAnalysis.analysis.rms import *
import sys
import os
from pocket_residues import *

# ----------------------------------------
# VARIABLE DECLARATION

pdb_file = sys.argv[1]
traj_file = sys.argv[2]
system = sys.argv[3]

zeros = np.zeros
dot_prod = np.dot
rmsd = MDAnalysis.analysis.rms.rmsd
sqrt = np.sqrt
flush = sys.stdout.flush

# ----------------------------------------
# SUBROUTINES:

def ffprint(string):
	print '%s' %(string)
	flush()

def summary(nSteps):
	sum_file = open('%s.diffusion.summary' %(system),'w')
	...

# ----------------------------------------
# MAIN:

ffprint('Loading Reference Structure')
ref = MDAnalysis.Universe(pdb_file)
ref_all = ref.select_atoms('all')
ref_align = ref.select_atoms(alignment)
ref_pocket = ref.select_atoms(pocket_sel)
ref_all.translate(-ref_align.center_of_mass())		### NEED TO DECIDE WHETHER TO align the betas or the pocket residues... DECIDE IF THE ORIGIN should be placed at the center of the pocket or alignment landmark...
ref0 = ref_align.positions
#ref0 = ref_pocket.positions

ffprint('Loading Analysis Universe')
u = MDAnalysis.Universe(pdb_file,traj_file)
u_all = u.select_atoms('all')
u_align = u.select_atoms(alignment)
wat = u.select_atoms(wat_resname)		### NEED TO CREATE A VARIABLE WITH THE CORRECT ATOM SELECTION FOR THE WATER RESIDUES...
u_pocket = u.select_atoms(pocket_sel)

nSteps = len(u.trajectory)			# number of steps
nWats = len(wat.residues)			# number of water residues
nAtoms = len(wat.atoms)			# number of atoms in water selection...
nAtoms0 = wat.atoms[0].number
nWats0 = wat.residues[0].resnum

if nWats*3 != nAtoms:
	ffprint('Something is fucked up. Selection issues. nWats*3 != nAtoms...')
	sys.exit()

# Memory Declaration
allCoord = zeros((nSteps,nAtoms,3),dtype=np.float64)	# array holding all xyz data for all atoms in the system
binary = zeros((nSteps,nWats),dtype=int)		# array holding the binary (yes or no) data about water residues within the distance cutoff for being present within the binding pocket
msd = zeros((nSteps,3),dtype=np.float64)		# array holding the msd data

# File Declaration
nRes_file = open('%s.nRes.dat' %(system),'w')	# File to print out the number of residues within the binding pocket
res_num = open('%s.waters.dat' %(system),'w')	# File to print out the atom numbers of the oxygen atom of TIP3 residues within the binding pocket selection
COG_file = open('%s.cog.xyz' %(system),'w')	# File to print a vmd xyz trajectory showing the motion of the COG of the binding pocket selection

ffprint('Beginning trajectory analysis')
# Loop through trajectory
for ts in u.trajectory:
	t = u_pocket.center_of_geometry()
	#Writing an xyz trajectory of the center of geometry of the binding pocket; the COG particle is labeled as a dummy atom X
	COG_file.write('1\n  generated by MDAnalysis and RBD\n X         %10.4f         %10.4f         %10.4f\n' %(t[0], t[1], t[2]))	
	# Align to reference (moves COG of the atp pocket to origin)
	u_all.translate(-u_align.center_of_mass())		### NEED TO DETERMINE WHERE ORIGIN SHOULD BE

	# obtain dimension values to be used for wrapping atoms
	dims = u.dimensions[:3]
	dims2 = dims/2.0
	# Fix the wrapping issues
	for i in range(0,nAtoms,3):
		temp = wat.atoms[i].positions
		t = wrapping(temp,dims,dims2)
		# translate the atoms of the residue using the translational matrix
		wat.atoms[i:i+3].translate(t)

	# Calculate the rotational matrix to align u to the ref, using the pocket selection as the reference selection
	R, rmsd = rotation_matrix(u_pocket.positions,ref0)
	u_all.rotate(R)

	x,y,z = u_pocket.center_of_geometry()

	pocket_waters = u.select_atoms('%s and byres point %s %s %s %d' %(wat_resname,x,y,z,radius)) # Atom selection for the waters within radius angstroms of the COG of the pocket	### CHECK THAT THIS ATOM SELECTION STILL WORKS
	
	nRes = len(pocket_waters.residues)
	num_atoms = nRes*3
	
	nRes_file.write('%d\n' %(nRes))		# Saving the number of water residues 

	for i in range(num_atoms):
		allCoord[ts.frame-1,pocket_waters.atoms[i].number-nAtoms0,:] = pocket_waters.atoms[i].positions	# Saving xyz coordinates of pocket waters to the allCoord array   ### NEED TO CHECK THAT THIS INDEXING WORKS

	for i in range(0,num_atom,3):
		binary[ts.frame-1, int((pocket_waters.atoms[i].number-nAtoms0)/3)] = 1		# Saving data to the binary array; ts.frame -1 is the correct index for the time frame; int(...)-nAtoms/3 corresponds to the correct index for the specific TIP3 water residue 		### NEED TO CHECK THAT THIS INDEXING WORKS
		res_num.write('%d    ' %(pocket_waters.atoms[i].number))			# Saving the atom number of the oxygen atom for the corresponding TIP3 residue
	res_num.write('\n')

ffprint('Done with saving coordinates of waters within the pocket, writing COG traj, etc...')

# Analyze Binary to determine which residues/timesteps are to be analyzed and perform dist2 analysis
ffprint('Beginning msd calculations (binary analysis and dist2 running average calcs)')
long_lived = set()
for i in range(nWats):
	for j in range(nSteps):
		if binary[j,i]==1:
			dt=1
			temp = 3*i
			pos0 = zeros((3,3),dtype=float)
			pos0 = allCoord[j,temp:temp+2,:]		### NEED to check that this data structure works well for the MSD function (distance_functions); also, that the indexing works to grab the correct data from allCoord
			
			while (j+dt)<nSteps and binary[j+dt,i]==1:
				if dt > 200:
					atom_num = 3*i + nAtoms0
					long_lived.add(atom_num)
				pos1 = zeros((3,3),dtype=float)
				pos1 = allCoord[j+dt,temp:temp+2,:]	### NEED to check that this data structure works well for the MSD function (distance_functions); also, that the indexing works to grab the correct data from allCoord
				dist2=0.
				
				#for k in range(3):		# loop through atoms of residue, i; assume that the residue has only three atoms (which is true for TIP3 water)
				#	temp = 0.0
				#	for l in range(3):
				#		temp = pos1[k,l] - pos0[k,l]
				#		dist2 += temp*temp
				#dist2 /= 3.0
				dist2 = MSD(pos0,pos1,3)	### NEED TO CHECK THAT THIS CALC GIVES THE SAME VALUE AS THE PREVIOUS VERSION
				msd[dt,0]+=1
				msd[dt,1]+= dist2
				msd[dt,2]+= dist2**2
				dt+=1

ffprint('Finished with dist2 calculations. Beginning to average and print out msd values')
msd_file = open('msd.pocket.dat','w')

for i in range(1,nSteps):
	if msd[i,0]>1.0:
		msd[i,1] /= msd[i,0]		# AVERAGE OF MSD
		msd[i,2] /= msd[i,0]		# AVERAGE OF MSD**2
	msd_file.write('%10.d    %10.d    %10.6f    %10.6f \n' %(i, msd[i,0], msd[i,1], msd[i,2]))
msd_file.close()

ffprint('Writing the unique TIP3 oxygen numbers that are found to be within the binding pocket for longer than 200 frames...')
nf = open('%s.long_lived.dat' %(system), 'w')
ll_list = list(long_lived)
nf.write('%s and same residue as index ' %(wat_resname))
for i in range(len(ll_list)):
	nf.write('%d ' %(ll_list[i]))
nf.write('\n')
nf.close()

