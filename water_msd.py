#!/Library/Frameworks/Python.framework/Versions/2.7/bin/python
##!/mnt/lustre_fs/users/mjmcc/apps/python2.7/bin/python
# ----------------------------------------
# USAGE:

# ----------------------------------------
# PREAMBLE:

import numpy as np
from numpy.linalg import *
import MDAnalysis
from MDAnalysis.analysis.align import *
import sys
import os
from distance_functions import *
from pocket_residues import *

# ----------------------------------------
# VARIABLE DECLARATION

pdb_file = sys.argv[1]
prmtop_file = sys.argv[2]
traj_file = sys.argv[3]
system = sys.argv[4]

zeros = np.zeros
dot_prod = np.dot
sqrt = np.sqrt
flush = sys.stdout.flush

# ----------------------------------------
# SUBROUTINES:

def ffprint(string):
	print '%s' %(string)
	flush()

def summary(nSteps):
	sum_file = open('%s.diffusion.summary' %(system),'w')
	sum_file.write('Using MDAnalysis version: %s\n' %(MDAnalysis.version.__version__))
	sum_file.write('To recreate this analysis, run this line:\n')
	for i in range(len(sys.argv)):
		sum_file.write('%s ' %(sys.argv[i]))
	sum_file.write('\n\n')
	sum_file.write('Reprinting the pocket_residues.py script for recreating this analysis:\n')
	sum_file.write("wat_resname = '%s'\n pocket_sel = '%s'\n radius = %f" %(wat_resname,pocket_sel,radius)) 
	sum_file.write('\n\n')
	sum_file.write('Output files are:\n')
	sum_file.write('	%s.nRes.dat 		--> holds the number of residues within the defined pocket\n' %(system))
	sum_file.write('	%s.waters.dat 		--> holds the atom numbers of the water oxygens that are within the defined pocket\n' %(system))
	sum_file.write('	%s.cog.xyz		--> A XYZ trajectory of the Center Of Geometry (COG) of the defined pocket; waters within radius of this point are considered within the defined pocket; Note you should always check that the radius is accurately describing all timesteps in your trajectory...\n' %(system))
	sum_file.write('	%s.msd.pocket.dat 	--> holds the dt, counts, <MSD>, and <MSD^2> data of waters within the defined pocket\n' %(system))
	sum_file.write('	%s.long_lived.dat	--> outputs a vmd atomselection to use to show the long lived waters in the un-truncated trajectories\n' %(system))
	sum_file.close()

# ----------------------------------------
# MAIN:
ffprint('Loading Analysis Universe.')
u = MDAnalysis.Universe(parameters['prmtop_file'],parameters['pdb_file'])
u_all = u.select_atoms('all')
wat = u.select_atoms(parameters['wat_resname'])
u_pocket = u.select_atoms(parameters['pocket_selection'])

ffprint('Grabbing the Positions of the Binding Pocket to use as reference.')
u_all.translate(-u_pocket.center_of_geometry())
pocket_ref = u_pocket.positions

ffprint('Loading in the trajectory.')
u.load_new(parameters['traj_file'])

nSteps = len(u.trajectory)		# number of steps
nWats = wat.n_residues			# number of water residues
nRes0 = wat.residues[0].index		# residue index is 0 indexed 

if nWats*3 != wat.n_atoms:
	ffprint('nWats*3 != wat.n_atoms. Unexpected number of water atoms. Possible selection error with water residue name.')
	sys.exit()

# Memory Declaration
oxygen_Coord = np.full((nSteps,nWats,3),np.nan)		# array holding all xyz data for water oxygens within the binding pocket; need initialize this array for all water residues since any residue could find its way into the pocket; filling this array with nan values for subsequent easy replacement and testing.
OH_vector = np.full(nSteps,nWats,3),np.nan)
msd = zeros((nSteps,3),dtype=np.float64)		# array holding the msd data

with open(parameters['number_of_wats_filename'],'w') as X, open(parameters['wat_res_nums_filename'],'w') as Y, open(parameters['center_of_geometry_filename'],'w') as Z:
	ffprint('Beginning trajectory analysis')
	# Loop through trajectory
	for ts in u.trajectory:
		t = u_pocket.center_of_geometry()
		Z.write('1\n  generated by MDAnalysis and RBD\n X         %10.4f         %10.4f         %10.4f\n' %(t[0], t[1], t[2]))	#Writing an xyz trajectory of the center of geometry of the binding pocket; the COG particle is labeled as a dummy atom X
		
		u_all.translate(-t)	# Align to reference (moves COG of the pocket to origin)

		if not parameters['Wrapped']:
			dims = u.dimensions[:3]	# obtain dimension values to be used for wrapping atoms
			dims2 = dims/2.0
			for i in range(nWats):
				temp = wat.reidues[i].atom[0].position
				t = wrapping(temp,dims,dims2)
				wat.residues[i].translate(t)

		R, rmsd = rotation_matrix(u_pocket.positions,pocket_ref)	# Calculate the rotational matrix to align u to the ref, using the pocket selection as the reference selection
		u_all.rotate(R)
	
		pocket_waters = wat.select_atoms('byres point 0 0 0 %d' %(parameters['radius'])) # Atom selection for the waters within radius angstroms of the COG of the pocket; Assumes that the COG of the pocket is at 0,0,0 xyz coordinates (which it should be bc the translational motion of the pocket is removed...
	
		nRes = pocket_waters.n_residues		# Calculate the number of wates within the pocket volume
		X.write('%d\n' %(nRes))		# Outputting the number of water residues at timestep ts

		timestep = ts.frame
		for i in range(nRes):
			res = pocket_waters.residues[i]		#
			res_index = res.resid			# grabbing the resid of the residue
			ox_pos = res.select_atoms('name O*').position
			hy_pos = res.select_atoms('name OH1').position
			oxygen_Coord[timestep,res_index,:] = ox_pos
			OH_vector[timestep,res_index,:] = (ox_pos - hy_pos)/parameters['water_OH_bond_dist'] # NO NEED TO CALC THE MAGNITUDE OF THIS VECTOR BECAUSE I KNOW IF FROM THE PARAMETERS OF TIP3 (OR OTHER WATER MODEL) 
			Y.write('%d   ' %(res_index+1))	# atom_num is zero-indexed; for vmd, need one-indexed values...
		Y.write('\n')

ffprint('Done with saving coordinates of waters within the pocket, O-H bond vectors, writing COG traj, etc.\n Beginning msd calculations.')

long_lived = set()
for i in range(nWats):		# Looping through all water residues.
	for j in range(nSteps):	# Looping through all timesteps for a single water.
		if oxygen_Coord[j,i,0] == oxygen_Coord[j,i,0]:	# boolean test to see if array object has a nan value or not; nan values will not equate and produce a FALSE;
			dt=1
			pos0 = oxygen_Coord[j,i,:]

			while (j+dt)<nSteps and oxygen_Coord[j+dt,i,0] == oxygen_Coord[j+dt,i,0]:	# 
				if dt == 200 and i+nRes0+1 not in long_lived:	# the water molecule has resided in the pocket for 200 frames (or more) AND has not been added to the set already;
					long_lived.add(i+nRes0+1)	# saving the one-indexed residue index for long-lived water molecules 
				pos1 = oxygen_Coord[j+dt,i,:]
				dist, dist2 = euclid_dist(pos0,pos1)	# Calculates the MSD of the oxygen atoms in the water molecule
				msd[dt,0]+=1		# count array element
				msd[dt,1]+= dist2	# sum of MSD values
				msd[dt,2]+= dist2**2	# sum of MSD^2 values
				dt+=1			# increment the dt value

ffprint('Finished with dist2 calculations. Beginning to average and print out msd values')

with open(parameters['msd_filename'],'w') as W:
	for i in range(1,nSteps):
		if msd[i,0]>1.0:
			msd[i,1]/=msd[i,0]	# Finish the average of the MSD value for the dt
			msd[i,2]/=msd[i,0]	# Finish the average of the MSD^2 value for the dt
		W.write('%10.d   %10.d   %10.6f   %10.6f \n' %(i,msd[i,0],msd[i,1],msd[i,2]))

ffprint('Writing the unique TIP3 oxygen numbers that are found to be within the binding pocket for longer than 200 frames.')
with open(parameters['long_lived_wat_filename'],'w') as W:
	ll_list = list(long_lived)
	W.write('resid ')
	for i in range(len(ll_list)):
		W. write('%d '%(ll_list[i]))
	W.write('\n')

### NEED TO ADD THE ANGULAR DIFFUSION ANALYSIS....




summary(nSteps)

